#!/bin/bash

# Script which tests the compiler against all test programs in exampleProgs

errorFlag=0
compFlag=0
# test_execute ($1 == file)
# Checks the file output
test_execute () {
  echo ">>> EXECUTING $1"
  fileLen=$(cat $1 | wc -l)
  fnameExt=$(basename $1 | head)
  fname=${fnameExt%.*}
  fnameAss="${fname}.s"
  # Extracting the expected output
  if [ -f $fnameAss ]
  then
    expOut=$(grep -PA $fileLen "# Output:" $1 | grep -PB $fileLen "#$")
    expOut="${expOut//# /}"
    # Executing the program
    aarch64-linux-gnu-gcc -o $fname -z noexecstack -march=armv8-a $fnameAss
    if [ $? -ne 0 ] 
    then
        errorFlag=1
        printf "<testcase name=\"$1\" >\n" >> temp
        printf "<failure message=\"Assembler failed - check logs!\" type=\"FAIL\" />\n" >> temp
        printf "</testcase>\n" >> temp
    else
      output=$(qemu-aarch64 -L /usr/aarch64-linux-gnu/ $fname) # Review
      # Comparing output to expected output
      IFS=$'\n' outputA=($output)
      IFS=$'\n' expectA=($expOut)
      
      outputL=${#outputA[@]}
      expectL=$((${#expectA[@]}-1))

      # TODO: Expected number of lines + exit status check
      if [ $outputL -ne $expectL ]
      then
          printf "Output does not have the expected number of lines\n"
          compFlag=1
      else
        for i in $(seq 1 ${#outputA[@]})
        do
          echo "$i"
          gLine=${outputA[i - 1]}
          echo "$eLine"
          eLine=${expectA[i]}
          echo "$gLine"
          if [ "$eLine" != "$gLine" ] 
          then
            printf "Unexpected output at line ${i}:\n   Exp: $eLine\n   Got: $gLine\n"
            compFlag=1
          fi
        done
      fi
      if [ $compFlag -eq 1 ]
      then
        errorFlag=1
        printf "<testcase name=\"$1\" >\n" >> temp
        printf "<failure message=\"Unexpected output - check logs!\" type=\"FAIL\" />\n" >> temp
        printf "</testcase>\n" >> temp
      else
        printf "<testcase name=\"$1\" />\n" >> temp
        echo "^^^ SUCCESS"
      fi
    fi
  else 
      errorFlag=1
      echo "!!! NO ASSEMBLY!"
      printf "<testcase name=\"$1\" >\n" >> temp
      printf "<failure message=\"No assembly!\" type=\"FAIL\" />\n" >> temp
      printf "</testcase>\n" >> temp
  fi
  compFlag=0
}

# test_compile ($1 == file, $2 == expected code)
# Checks if the file it to be combiled and 
# Attempts to compileit and compares the exit code
# to the expected. Saves the results in temp
test_compile () {
  if [[ $file == \'* ]]
  then
    #echo "*** SKIPING TEST ${1:1}"
    printf "<testcase name=\"${1:1}\" >\n" >> temp
    printf "<skipped message=\"The program ${1:1} has been skipped\"/>\n" >> temp
    printf "</testcase>\n" >> temp
  else
    echo ">>> TESTING $1"
    ./compile $1
    code=$?
    if [ $code -eq $2 ]
    then
      if [ $code -eq 0 ]
      then
        test_execute $1
      fi
    else
      errorFlag=1
      printf "<testcase name=\"$1\" >\n" >> temp
      printf "<failure message=\"Expected exit code = $2, got $code\" type=\"FAIL\" />\n" >> temp
      printf "</testcase>\n" >> temp
    fi
  fi
}

# count_results ($1 == testsuite_name, $2 == results_file)
# Counts how many test cases have failed and stores the results in 
# results_file
count_results () {
  fails=$(cat temp | grep -E "(FAIL)" | wc -l)
  tests=$(cat temp | grep -E "testcase name=" | wc -l)
  skipped=$(cat temp | grep -E "skipped" | wc -l)
  printf "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n" > $2
  printf "<testsuite name=\"Programs at: $1\" tests=\"$tests\" failures=\"$fails\"  skipped=\"$skipped\">\n" >> $2
  cat temp >> $2
  printf "</testsuite>\n" >> $2
}

#make

# Test results for valid tests
fileLs=$(cat exampleProgs/valid.selection | tr " " "\n")
printf "" > temp
for file in $fileLs
do
  test_compile $file 0
done
count_results "valid folder" "validRes.xml"

# Test result for syntax errors

fileLs=$(cat exampleProgs/syntax.selection | tr " " "\n")
printf "" > temp
for file in $fileLs
do
  test_compile $file 100
done
count_results "syntax folder" "syntaxRes.xml"

# Test result for semantic errors

fileLs=$(cat exampleProgs/semantic.selection | tr " " "\n")
printf "" > temp
for file in $fileLs
do
  test_compile $file 200
done
count_results "semantic folder" "semanticRes.xml"

rm temp

exit $errorFlag