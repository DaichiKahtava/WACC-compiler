#!/bin/bash

# Script which tests the compiler against all test programs in exampleProgs

errorFlag=0

compFlag=0
# test_execute ($1 == file)
# Checks the file output
test_execute () {
  echo ">>> EXECUTING $1"
  fileLen=$(cat $1 | wc -l)
  fnameExt=$(basename $1 | head)
  fname=${fnameExt%.*}
  fnameAss="${fname}.s"
  echo $fnameAss
  # Extracting the expected output
  if [ -f $fnameAss ]
  then
    expOut=$(grep -PA $fileLen "# Output:" exampleProgs/valid/function/simple_functions/sameArgName.wacc | grep -PB $fileLen "#$" | tr -d '# ')
    # Executing the program
    aarch64-linux-gnu-gcc -o $fname -z noexecstack -march=armv8-a $fnameAss
    output=$(qemu-aarch64 -L /usr/aarch64-linux-gnu/ $fname | tr " " "\n") # Review
    output=( "Output:" "${arrayA[@]}" )
    # Comparing output to expected output
    for i in $(seq 1 ${#arr[@]})
    do
      echo $output[i - 1]
      echo $expOut[i - 1]
      if [ $output[i - 1] -ne $expOut[i - 1] ] 
      then
        compFlag=1
      fi
    done

    if [ $compFlag -eq 1 ]
    then
      printf "<testcase name=\"$1\" >\n" >> temp
      printf "<failure message=\"Unexpected output!\" type=\"FAIL\" />\n" >> temp
      printf "</testcase>\n" >> temp
    else
      printf "<testcase name=\"$1\" />\n" >> temp
    fi
  else 
      echo "!!! NO EXECUTABLE!"
      printf "<testcase name=\"$1\" >\n" >> temp
      printf "<failure message=\"No Executable!\" type=\"FAIL\" />\n" >> temp
      printf "</testcase>\n" >> temp
  fi
  compFlag=0
}

# test_compile ($1 == file, $2 == expected code)
# Checks if the file it to be combiled and 
# Attempts to compileit and compares the exit code
# to the expected. Saves the results in temp
test_compile () {
  if [[ $file == \'* ]]
  then
    echo "*** SKIPING TEST ${1:1}"
    printf "<testcase name=\"${1:1}\" >\n" >> temp
    printf "<skipped message=\"The program ${1:1} has been skipped\"/>\n" >> temp
    printf "</testcase>\n" >> temp
  else
    echo ">>> TESTING $1"
    ./compile $1
    code=$?
    if [ $code -eq $2 ]
    then
      if [ $code -eq 0 ]
      then
        test_execute $1
      fi
    else
      errorFlag=1
      printf "<testcase name=\"$1\" >\n" >> temp
      printf "<failure message=\"Expected exit code = $2, got $code\" type=\"FAIL\" />\n" >> temp
      printf "</testcase>\n" >> temp
    fi
  fi
}

# count_results ($1 == testsuite_name, $2 == results_file)
# Counts how many test cases have failed and stores the results in 
# results_file
count_results () {
  fails=$(cat temp | grep -E "(FAIL)" | wc -l)
  tests=$(cat temp | grep -E "testcase name=" | wc -l)
  skipped=$(cat temp | grep -E "skipped" | wc -l)
  printf "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n" > $2
  printf "<testsuite name=\"Programs at: $1\" tests=\"$tests\" failures=\"$fails\"  skipped=\"$skipped\">\n" >> $2
  cat temp >> $2
  printf "</testsuite>\n" >> $2
}

#make

# Test results for valid tests
fileLs=$(cat exampleProgs/valid.selection | tr " " "\n")
printf "" > temp
for file in $fileLs
do
  test_compile $file 0
done
count_results "valid folder" "validRes.xml"

# Test result for syntax errors

fileLs=$(cat exampleProgs/syntax.selection | tr " " "\n")
printf "" > temp
for file in $fileLs
do
  test_compile $file 100
done
count_results "syntax folder" "syntaxRes.xml"

# Test result for semantic errors

fileLs=$(cat exampleProgs/semantic.selection | tr " " "\n")
printf "" > temp
for file in $fileLs
do
  test_compile $file 200
done
count_results "semantic folder" "semanticRes.xml"

rm temp

exit $errorFlag